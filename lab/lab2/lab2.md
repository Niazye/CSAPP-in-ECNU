# Lab2

## Phase 1

![Phase\_1\_ASM](./Screenshots/Phase_1_ASM.png "Phase 1 ASM")

看到 `phase_1` 的 `explode_bomb` 在 `0x400ef2` 行，需要通过 `0x400ef0` 行的 `je` 控制语句来跳过

`je` 语句使用上一行的 `test` 语句，`test` 返回操作数本身，故需要让 `%eax` 为 `0`，`%eax` 一般是上一个函数（本题中即为 `string_not_equal`）的返回值。猜测该函数是检测两个字符串是否不相等，本题需要让它们相等，其中一个参数通过标准输入，另一个则是由上一行的 `mov $0x402400, %rsi` 传入

因此，需要让输入的字符串与 `0x402400` 处的字符串相等，使用 `x/s 0x402400` 查看 `0x402400` 处的字符串，得到结果
![Phase\_1\0x402411](./Screenshots/Phase1_0x402400.png)

**Phase1: Border relations with Canada have never been better.**

## Phase 2

![Phase\_2\_ASM](./Screenshots/Phase_2_ASM.png "Phase 2 ASM")

在 `0x400f05` 行读入 6 个数字，记作 `a[0]` 至 `a[5]`。`0x400f0a` 与 `0x400f0e` 两行要求栈顶 `%rsp` 也就是 `a[0]` 为 1. 当满足 `a[0] == 1` 时，`jmp` 至 `0x400f30` 进行初始化 `%rbx = %rsp + 0x4, %rbp = %rsp + 0x18`，分别表示 `a[1]` 和 `a[6]` 的地址，然后进入 `0x400f17` 与 `0x400f3a` 之间的循环部分（图中黄色区域）
`0x400f17`, `0x400f1a`, `0x400f1c` 三行实现了将 `*(%rbx - 4)` 的两倍与 `*(%rbx)` （也就是将 `%rbx` 对应数组元素与它的前一项的两倍）的比较，`0x400f1e` 行若比较结果不相等则引爆炸弹，因此需要比较结果相等，`0x400f25` 在每次比较后将 `%rbx += 4`，即比较下一项。`0x400f29` 在 `%rbx == %rbp (== $rsp + 0x18)` （即到达数组末尾）时结束循环，最终 `return`

综上，`phase_2` 实现检测一个长度为 6 的数组，以 `1` 开头，且每一项是前一项的两倍

**Phase2: 1 2 4 8 16 32**

## Phase 3

![Phase\_3\_ASM\_Part1](./Screenshots/Phase_3_ASM_Part1.png)
`0x400f5b` 行至 `0x400f71` 行输入至少两个数字，并将第一个数字（经过多次不同输入测试得出，这两个数字的存放位置不在栈顶，而是栈顶下 `8` 字节与 `12` 字节处）存入 `%eax` 且保证第一个数字是不大于 `7` 的非负数。

![Phase\_3\_ASM\_Part2](./Screenshots/Phase_3_ASM_Part2.png)

`0x400f75` 根据输入的第一个数字的值，获取对应地址处（具体为 `0x402470 + 8 * %rax`）存放的另一个值，并间接跳转到该值存储的地址处，可以注意到，`jmp` 间接跳转的目标地址都是其下方某个 `mov` 指令的地址，所有 `mov` 之后都会到达 `0x400fbe` 处的 `cmp` （包括 `jmp` 至的和恰好顺序执行到的）

综上，可以总结为 `phase_3` 中生成了一个 `switch-case` 所需要的跳转表，不同的 `case` 对应不同的另一个数字，如果输入的两个数字在 `switch-case` 中存在匹配的组合则通关

通过数次的尝试得到的对应关系如下

```mermaid
    graph
    A0[0] --> B0[0x402470 + 0] --> C0[0x400f7c] --> D0[0xcf == 207]
    A1[1] --> B1[0x402470 + 8] --> C1[0x400fb9] --> D1[0x137 == 311]
    A2[2] --> B2[0x402470 + 16] --> C2[0x400f83] --> D2[0x2c3 == 707]
    A3[3] --> B3[0x402470 + 24] --> C3[0x400f8a] --> D3[0x100 == 256]
    A4[4] --> B4[0x402470 + 32] --> C4[0x400f91] --> D4[0x185 == 389]
    A5[5] --> B5[0x402470 + 40] --> C5[0x400f98] --> D5[0xce == 206]
    A6[6] --> B6[0x402470 + 48] --> C6[0x400f9f] --> D6[0x2aa == 682]
    A7[7] --> B7[0x402470 + 56] --> C7[0x400fa6] --> D7[0x147 == 327]
```

任意输入其中一对即可，例如 `3 256`

**Phase3: 0 207 || 1 311 || 2 707 || 3 256 || 4 389 || 5 206 || 6 682 || 7 327**

## Phase 4

![Phase\_4\_ASM\_Part1](./Screenshots/Phase_4_ASM_Part1.png)

首先读入恰好两个整数（若不为两个则引爆炸弹）存入 `$rsp + 8` 和 `$rsp + 16`，且保证第一个数是不大于 `14` 的非负数

将 `%edx` `%esi` `%edi` 分别初始化为 `14` `0` `*($rsp + 8)` 后进入函数 `func4`，得到函数返回值 `%eax`，检查 `%eax` 是否为 `0`，若不为 `0` 则引爆，后检测 `*(%rsp + 12)` （也就是输入的第二个数字）与 `0` 是否相等，若相等则跳过引爆（即输入的第二个数字如果不等于 `0` 则引爆），则重点在于 `func4` 中的内容

![Phase\_4\_ASM\_Part2](./Screenshots/Phase_4_ASM_Part2.png)

`0x400fd2` 至 `0x400fdf` 进行了如下操作，（使用 c 格式表示，注释内代入初始化的数值）:
```c
%eax = %edx - %esi                      //( == 14 - 0 == 14)
%ecx = %eax                             //( == 14)
%eax = %eax + ((unsigned)%ecx >> 31)    //( == 14 + (14 >> 31) == 14)
%eax = %eax >> 1                        //( == 14 >> 1 == 7)
%ecx = %rax + %rsi                      //( == 7 + 0 == 7)
```
比较 `%edi`（输入的第一个数字）与 `%ecx (== 7)`，如果 `7 <= %edi` 则跳转至 `0x400ff2`

在 `0x400ff2` 令 `%eax = 0` 后比较 `%ecx (== 7)` 与 `%edi` 如果 `7 >= %edi` 则跳转至 `0x401007`

至此函数跳过了其中全部的递归调用直接返回，同时 `%eax` 恰为所需要的 `0`，因此只需要使 `%edi >= 7` 且 `%edi <= 7` 即可直接通过 `func4`，而 `%edi` 即是输入的第一个数字，因此输入的第一个数字只需为 `7` 即可

同时可以注意到输入的第二个数字 （位置在`%rsp + 12`） 始终不受影响，因此其始终不变，由上文可知它应为 `0`。

综上可得到该阶段可行的一个答案

**Phase4: 7 0**

## Phase 5

![Phase\_5\_ASM](./Screenshots/Phase_5_ASM.png)

经查阅了解从 `0x40106a` 至 `0x401073` 部分是保证程序鲁棒性的安全措施，不影响解题，故忽略。

程序核心部分从 `0x401078` 开始，首先检测输入的字符串长度（从 `string_length` 函数的名称可猜测得出，需要为 `6`。

在 `0x401089` 处跳转至 `0x4010d2` 将 `%eax` 置零再回到 `0x40108b` 进入 `0x40108b` 至 `0x4010ac` 之间的循环，其中 `%rax` 作为循环变量从 `0` 至 `5`，当到达 `6` 时结束循环

循环体：
将 `(%rbx + %rax)` 地址处的变量存入 `%ecx`，将 `%cl` （`%ecx` 的低 `8` 位）存入栈顶和 `%rdx` 中并保留后者的低 `4` 位。
取 `(0x4024b0 + %rdx)` 地址处的值替换掉 `%rdx`，再将它的低 `8` 位存入 `(%rsp + %rax + 16)` 的地址处。
其中 `%rbx` 是输入的字符串的首地址，`%rax` 是循环变量，`%ecx / %cl` 和 `%rsp` 作为中间变量。

以上循环体实现以下功能，将 `*(%rbx + %rax)` 的数值取低 `4` 位（即对 `16` 取模），记作 `temp`，取 `*(0x4024b0 + temp)` 处的数值存入栈顶下 `(16 + %rsp)` 字节处。由于 `%rax` 是从 `0` 至 `5` 的自变量，因此会对整个字符串执行如上操作。最终整个字符串会变为另一个串保存。

查看 `0x4024b0` 处的字符串可以推测出转换规则。

`0x4010ae` 在保存的新串后添加结束符 `'\0'`。

`0x4010b3` 和 `0x4010b8` 分别将 `0x40245e` 的某个串与输入串转换后的新串作为参数传入下面的 `strings_not_equal` 函数，若相等则 `je` 至 `0x4010e9` 结束函数，成功拆弹。

查看 `0x40245e` 处的串。![Phase\_5\_0x40245e](./Screenshots/Phase5_0x40245e.png)

发现我们要让输入串转变为 `"flyers"`

查看 `0x4024b0` 处的串。![Phase\_5\_0x4024b0](./Screenshots/Phase5_0x4024b0.png)

由于转换式有对 `16` 取模操作，转换只需要前 `16` 个字符 `"maduiersnfotvbyl"`。其余字符串是在程序执行过程中输入 `Ctrl + C` 时的提示语，与本题无关。

在串中找到 `"flyers"` 分别在 `9` `15` `14` `5` `6` `7` 处。由前面的转换规则：“输入字符对 `16` 取模”，需要输入 `6` 个对 `16` 取模后分别为这些数值的字符，查询 `ASCII` 码表得到

```mermaid
    graph
    A9[x % 0x10 == 0x9] --> B9["')' '9' 'I' 'Y' 'i' 'y'"]
    A15[x % 0x10 == 0xF] --> B15["'/' '?' 'O' '_' 'o'"]
    A14[x % 0x10 == 0xE] --> B14["'.' '>' 'N' '^' 'n' '~'"]
    A5[x % 0x10 == 0x5] --> B5["'%' '5' 'E' 'U' 'e' 'u'"]
    A6[x % 0x10 == 0x6] --> B6["'&' '6' 'F' 'V' 'f' 'v'"]
    A7[x % 0x10 == 0x7] --> B7["''' '7' 'G' 'W' 'g' 'w'"] 
```
如上对应关系，第二行的每个框中各选择一个字符即可，例如：

**Phase5: ionefg**

## Phase 6

