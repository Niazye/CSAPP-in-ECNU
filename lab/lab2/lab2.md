# Lab2

## Phase 1

![Phase\_1\_ASM](./Screenshots/Phase_1_ASM.png "Phase 1 ASM")

看到 `phase_1` 的 `explode_bomb` 在 `0x400ef2` 行，需要通过 `0x400ef0` 行的 `je` 控制语句来跳过

`je` 语句使用上一行的 `test` 语句，`test` 返回操作数本身，故需要让 `%eax` 为 `0`，`%eax` 一般是上一个函数（本题中即为 `string_not_equal`）的返回值。猜测该函数是检测两个字符串是否不相等，本题需要让它们相等，其中一个参数通过标准输入，另一个则是由上一行的 `mov $0x402400, %rsi` 传入

因此，需要让输入的字符串与 `0x402400` 处的字符串相等，使用 `x/s 0x402400` 查看 `0x402400` 处的字符串，得到结果
![Phase\_1\0x402411](./Screenshots/Phase1_0x402400.png)

**Phase1: Border relations with Canada have never been better.**

## Phase 2

![Phase\_2\_ASM](./Screenshots/Phase_2_ASM.png "Phase 2 ASM")

在 `0x400f05` 行读入 6 个数字，记作 `a[0]` 至 `a[5]`。`0x400f0a` 与 `0x400f0e` 两行要求栈顶 `%rsp` 也就是 `a[0]` 为 1. 当满足 `a[0] == 1` 时，`jmp` 至 `0x400f30` 进行初始化 `%rbx = %rsp + 0x4, %rbp = %rsp + 0x18`，分别表示 `a[1]` 和 `a[6]` 的地址，然后进入 `0x400f17` 与 `0x400f3a` 之间的循环部分（图中黄色区域）
`0x400f17`, `0x400f1a`, `0x400f1c` 三行实现了将 `*(%rbx - 4)` 的两倍与 `*(%rbx)` （也就是将 `%rbx` 对应数组元素与它的前一项的两倍）的比较，`0x400f1e` 行若比较结果不相等则引爆炸弹，因此需要比较结果相等，`0x400f25` 在每次比较后将 `%rbx += 4`，即比较下一项。`0x400f29` 在 `%rbx == %rbp (== $rsp + 0x18)` （即到达数组末尾）时结束循环，最终 `return`

综上，`phase_2` 实现检测一个长度为 6 的数组，以 `1` 开头，且每一项是前一项的两倍

**Phase2: 1 2 4 8 16 32**

## Phase 3

![Phase\_3\_ASM\_Part1](./Screenshots/Phase_3_ASM_Part1.png)
`0x400f5b` 行至 `0x400f71` 行输入至少两个数字，并将第一个数字（经过多次不同输入测试得出，这两个数字的存放位置不在栈顶，而是栈顶下 `8` 字节与 `12` 字节处）存入 `%eax` 且保证第一个数字是不大于 `7` 的非负数。

![Phase\_3\_ASM\_Part2](./Screenshots/Phase_3_ASM_Part2.png)

`0x400f75` 根据输入的第一个数字的值，获取对应地址处（具体为 `0x402470 + 8 * %rax`）存放的另一个值，并间接跳转到该值存储的地址处，可以注意到，`jmp` 间接跳转的目标地址都是其下方某个 `mov` 指令的地址，所有 `mov` 之后都会到达 `0x400fbe` 处的 `cmp` （包括 `jmp` 至的和恰好顺序执行到的）

综上，可以总结为 `phase_3` 中生成了一个 `switch-case` 所需要的跳转表，不同的 `case` 对应不同的另一个数字，如果输入的两个数字在 `switch-case` 中存在匹配的组合则通关

通过数次的尝试得到的对应关系如下

```mermaid
    graph
    A0[0] --> B0[0x402470 + 0] --> C0[0x400f7c] --> D0[0xcf == 207]
    A1[1] --> B1[0x402470 + 8] --> C1[0x400fb9] --> D1[0x137 == 311]
    A2[2] --> B2[0x402470 + 16] --> C2[0x400f83] --> D2[0x2c3 == 707]
    A3[3] --> B3[0x402470 + 24] --> C3[0x400f8a] --> D3[0x100 == 256]
    A4[4] --> B4[0x402470 + 32] --> C4[0x400f91] --> D4[0x185 == 389]
    A5[5] --> B5[0x402470 + 40] --> C5[0x400f98] --> D5[0xce == 206]
    A6[6] --> B6[0x402470 + 48] --> C6[0x400f9f] --> D6[0x2aa == 682]
    A7[7] --> B7[0x402470 + 56] --> C7[0x400fa6] --> D7[0x147 == 327]
```

任意输入其中一对即可，例如 `3 256`

**Phase3: 0 207 || 1 311 || 2 707 || 3 256 || 4 389 || 5 206 || 6 682 || 7 327**

## Phase 4

![Phase\_4\_ASM\_Part1](./Screenshots/Phase_4_ASM_Part1.png)

首先读入恰好两个整数（若不为两个则引爆炸弹）存入 `$rsp + 8` 和 `$rsp + 16`，且保证第一个数是不大于 `14` 的非负数

将 `%edx` `%esi` `%edi` 分别初始化为 `14` `0` `*($rsp + 8)` 后进入函数 `func4`，得到函数返回值 `%eax`，检查 `%eax` 是否为 `0`，若不为 `0` 则引爆，后检测 `*(%rsp + 12)` （也就是输入的第二个数字）与 `0` 是否相等，若相等则跳过引爆（即输入的第二个数字如果不等于 `0` 则引爆），则重点在于 `func4` 中的内容

![Phase\_4\_ASM\_Part2](./Screenshots/Phase_4_ASM_Part2.png)

`0x400fd2` 至 `0x400fdf` 进行了如下操作，（使用 c 格式表示，注释内代入初始化的数值）:
```c
%eax = %edx - %esi                      //( == 14 - 0 == 14)
%ecx = %eax                             //( == 14)
%eax = %eax + ((unsigned)%ecx >> 31)    //( == 14 + (14 >> 31) == 14)
%eax = %eax >> 1                        //( == 14 >> 1 == 7)
%ecx = %rax + %rsi                      //( == 7 + 0 == 7)
```
比较 `%edi`（输入的第一个数字）与 `%ecx (== 7)`，如果 `7 <= %edi` 则跳转至 `0x400ff2`

在 `0x400ff2` 令 `%eax = 0` 后比较 `%ecx (== 7)` 与 `%edi` 如果 `7 >= %edi` 则跳转至 `0x401007`

至此函数跳过了其中全部的递归调用直接返回，同时 `%eax` 恰为所需要的 `0`，因此只需要使 `%edi >= 7` 且 `%edi <= 7` 即可直接通过 `func4`，而 `%edi` 即是输入的第一个数字，因此输入的第一个数字只需为 `7` 即可

同时可以注意到输入的第二个数字 （位置在`%rsp + 12`） 始终不受影响，因此其始终不变，由上文可知它应为 `0`。

综上可得到该阶段可行的一个答案

**Phase4: 7 0**

## Phase 5

