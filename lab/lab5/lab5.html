<!DOCTYPE html><html><head>
      <title>lab5</title>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      
      <link rel="stylesheet" href="file:///c:\Users\niazye\.vscode\extensions\shd101wyy.markdown-preview-enhanced-0.8.18\crossnote\dependencies\katex\katex.min.css">
      
      
      
      
      
      <style>
      code[class*=language-],pre[class*=language-]{color:#333;background:0 0;font-family:Consolas,"Liberation Mono",Menlo,Courier,monospace;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.4;-moz-tab-size:8;-o-tab-size:8;tab-size:8;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{padding:.8em;overflow:auto;border-radius:3px;background:#f5f5f5}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal;background:#f5f5f5}.token.blockquote,.token.comment{color:#969896}.token.cdata{color:#183691}.token.doctype,.token.macro.property,.token.punctuation,.token.variable{color:#333}.token.builtin,.token.important,.token.keyword,.token.operator,.token.rule{color:#a71d5d}.token.attr-value,.token.regex,.token.string,.token.url{color:#183691}.token.atrule,.token.boolean,.token.code,.token.command,.token.constant,.token.entity,.token.number,.token.property,.token.symbol{color:#0086b3}.token.prolog,.token.selector,.token.tag{color:#63a35c}.token.attr-name,.token.class,.token.class-name,.token.function,.token.id,.token.namespace,.token.pseudo-class,.token.pseudo-element,.token.url-reference .token.variable{color:#795da3}.token.entity{cursor:help}.token.title,.token.title .token.punctuation{font-weight:700;color:#1d3e81}.token.list{color:#ed6a43}.token.inserted{background-color:#eaffea;color:#55a532}.token.deleted{background-color:#ffecec;color:#bd2c00}.token.bold{font-weight:700}.token.italic{font-style:italic}.language-json .token.property{color:#183691}.language-markup .token.tag .token.punctuation{color:#333}.language-css .token.function,code.language-css{color:#0086b3}.language-yaml .token.atrule{color:#63a35c}code.language-yaml{color:#183691}.language-ruby .token.function{color:#333}.language-markdown .token.url{color:#795da3}.language-makefile .token.symbol{color:#795da3}.language-makefile .token.variable{color:#183691}.language-makefile .token.builtin{color:#0086b3}.language-bash .token.keyword{color:#0086b3}pre[data-line]{position:relative;padding:1em 0 1em 3em}pre[data-line] .line-highlight-wrapper{position:absolute;top:0;left:0;background-color:transparent;display:block;width:100%}pre[data-line] .line-highlight{position:absolute;left:0;right:0;padding:inherit 0;margin-top:1em;background:hsla(24,20%,50%,.08);background:linear-gradient(to right,hsla(24,20%,50%,.1) 70%,hsla(24,20%,50%,0));pointer-events:none;line-height:inherit;white-space:pre}pre[data-line] .line-highlight:before,pre[data-line] .line-highlight[data-end]:after{content:attr(data-start);position:absolute;top:.4em;left:.6em;min-width:1em;padding:0 .5em;background-color:hsla(24,20%,50%,.4);color:#f4f1ef;font:bold 65%/1.5 sans-serif;text-align:center;vertical-align:.3em;border-radius:999px;text-shadow:none;box-shadow:0 1px #fff}pre[data-line] .line-highlight[data-end]:after{content:attr(data-end);top:auto;bottom:.4em}html body{font-family:'Helvetica Neue',Helvetica,'Segoe UI',Arial,freesans,sans-serif;font-size:16px;line-height:1.6;color:#333;background-color:#fff;overflow:initial;box-sizing:border-box;word-wrap:break-word}html body>:first-child{margin-top:0}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{line-height:1.2;margin-top:1em;margin-bottom:16px;color:#000}html body h1{font-size:2.25em;font-weight:300;padding-bottom:.3em}html body h2{font-size:1.75em;font-weight:400;padding-bottom:.3em}html body h3{font-size:1.5em;font-weight:500}html body h4{font-size:1.25em;font-weight:600}html body h5{font-size:1.1em;font-weight:600}html body h6{font-size:1em;font-weight:600}html body h1,html body h2,html body h3,html body h4,html body h5{font-weight:600}html body h5{font-size:1em}html body h6{color:#5c5c5c}html body strong{color:#000}html body del{color:#5c5c5c}html body a:not([href]){color:inherit;text-decoration:none}html body a{color:#08c;text-decoration:none}html body a:hover{color:#00a3f5;text-decoration:none}html body img{max-width:100%}html body>p{margin-top:0;margin-bottom:16px;word-wrap:break-word}html body>ol,html body>ul{margin-bottom:16px}html body ol,html body ul{padding-left:2em}html body ol.no-list,html body ul.no-list{padding:0;list-style-type:none}html body ol ol,html body ol ul,html body ul ol,html body ul ul{margin-top:0;margin-bottom:0}html body li{margin-bottom:0}html body li.task-list-item{list-style:none}html body li>p{margin-top:0;margin-bottom:0}html body .task-list-item-checkbox{margin:0 .2em .25em -1.8em;vertical-align:middle}html body .task-list-item-checkbox:hover{cursor:pointer}html body blockquote{margin:16px 0;font-size:inherit;padding:0 15px;color:#5c5c5c;background-color:#f0f0f0;border-left:4px solid #d6d6d6}html body blockquote>:first-child{margin-top:0}html body blockquote>:last-child{margin-bottom:0}html body hr{height:4px;margin:32px 0;background-color:#d6d6d6;border:0 none}html body table{margin:10px 0 15px 0;border-collapse:collapse;border-spacing:0;display:block;width:100%;overflow:auto;word-break:normal;word-break:keep-all}html body table th{font-weight:700;color:#000}html body table td,html body table th{border:1px solid #d6d6d6;padding:6px 13px}html body dl{padding:0}html body dl dt{padding:0;margin-top:16px;font-size:1em;font-style:italic;font-weight:700}html body dl dd{padding:0 16px;margin-bottom:16px}html body code{font-family:Menlo,Monaco,Consolas,'Courier New',monospace;font-size:.85em;color:#000;background-color:#f0f0f0;border-radius:3px;padding:.2em 0}html body code::after,html body code::before{letter-spacing:-.2em;content:'\00a0'}html body pre>code{padding:0;margin:0;word-break:normal;white-space:pre;background:0 0;border:0}html body .highlight{margin-bottom:16px}html body .highlight pre,html body pre{padding:1em;overflow:auto;line-height:1.45;border:#d6d6d6;border-radius:3px}html body .highlight pre{margin-bottom:0;word-break:normal}html body pre code,html body pre tt{display:inline;max-width:initial;padding:0;margin:0;overflow:initial;line-height:inherit;word-wrap:normal;background-color:transparent;border:0}html body pre code:after,html body pre code:before,html body pre tt:after,html body pre tt:before{content:normal}html body blockquote,html body dl,html body ol,html body p,html body pre,html body ul{margin-top:0;margin-bottom:16px}html body kbd{color:#000;border:1px solid #d6d6d6;border-bottom:2px solid #c7c7c7;padding:2px 4px;background-color:#f0f0f0;border-radius:3px}@media print{html body{background-color:#fff}html body h1,html body h2,html body h3,html body h4,html body h5,html body h6{color:#000;page-break-after:avoid}html body blockquote{color:#5c5c5c}html body pre{page-break-inside:avoid}html body table{display:table}html body img{display:block;max-width:100%;max-height:100%}html body code,html body pre{word-wrap:break-word;white-space:pre}}.markdown-preview{width:100%;height:100%;box-sizing:border-box}.markdown-preview ul{list-style:disc}.markdown-preview ul ul{list-style:circle}.markdown-preview ul ul ul{list-style:square}.markdown-preview ol{list-style:decimal}.markdown-preview ol ol,.markdown-preview ul ol{list-style-type:lower-roman}.markdown-preview ol ol ol,.markdown-preview ol ul ol,.markdown-preview ul ol ol,.markdown-preview ul ul ol{list-style-type:lower-alpha}.markdown-preview .newpage,.markdown-preview .pagebreak{page-break-before:always}.markdown-preview pre.line-numbers{position:relative;padding-left:3.8em;counter-reset:linenumber}.markdown-preview pre.line-numbers>code{position:relative}.markdown-preview pre.line-numbers .line-numbers-rows{position:absolute;pointer-events:none;top:1em;font-size:100%;left:0;width:3em;letter-spacing:-1px;border-right:1px solid #999;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.markdown-preview pre.line-numbers .line-numbers-rows>span{pointer-events:none;display:block;counter-increment:linenumber}.markdown-preview pre.line-numbers .line-numbers-rows>span:before{content:counter(linenumber);color:#999;display:block;padding-right:.8em;text-align:right}.markdown-preview .mathjax-exps .MathJax_Display{text-align:center!important}.markdown-preview:not([data-for=preview]) .code-chunk .code-chunk-btn-group{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .status{display:none}.markdown-preview:not([data-for=preview]) .code-chunk .output-div{margin-bottom:16px}.markdown-preview .md-toc{padding:0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link div,.markdown-preview .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}.markdown-preview .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}.scrollbar-style::-webkit-scrollbar{width:8px}.scrollbar-style::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}.scrollbar-style::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode]){position:relative;width:100%;height:100%;top:0;left:0;margin:0;padding:0;overflow:auto}html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{position:relative;top:0;min-height:100vh}@media screen and (min-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em calc(50% - 457px + 2em)}}@media screen and (max-width:914px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode]) .markdown-preview{font-size:14px!important;padding:1em}}@media print{html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{display:none}}html body[for=html-export]:not([data-presentation-mode]) #sidebar-toc-btn{position:fixed;bottom:8px;left:8px;font-size:28px;cursor:pointer;color:inherit;z-index:99;width:32px;text-align:center;opacity:.4}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] #sidebar-toc-btn{opacity:1}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc{position:fixed;top:0;left:0;width:300px;height:100%;padding:32px 0 48px 0;font-size:14px;box-shadow:0 0 4px rgba(150,150,150,.33);box-sizing:border-box;overflow:auto;background-color:inherit}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar{width:8px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-track{border-radius:10px;background-color:transparent}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc::-webkit-scrollbar-thumb{border-radius:5px;background-color:rgba(150,150,150,.66);border:4px solid rgba(150,150,150,.66);background-clip:content-box}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc a{text-decoration:none}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc{padding:0 16px}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link{display:inline;padding:.25rem 0}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link div,html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper .md-toc-link p{display:inline}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .md-sidebar-toc .md-toc .md-toc-link-wrapper.highlighted .md-toc-link{font-weight:800}html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{left:300px;width:calc(100% - 300px);padding:2em calc(50% - 457px - 300px / 2);margin:0;box-sizing:border-box}@media screen and (max-width:1274px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{padding:2em}}@media screen and (max-width:450px){html body[for=html-export]:not([data-presentation-mode])[html-show-sidebar-toc] .markdown-preview{width:100%}}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .markdown-preview{left:50%;transform:translateX(-50%)}html body[for=html-export]:not([data-presentation-mode]):not([html-show-sidebar-toc]) .md-sidebar-toc{display:none}
/* Please visit the URL below for more information: */
/*   https://shd101wyy.github.io/markdown-preview-enhanced/#/customize-css */

      </style>
      <!-- The content below will be included at the end of the <head> element. --><script type="text/javascript">
  document.addEventListener("DOMContentLoaded", function () {
    // your code here
  });
</script></head><body for="html-export">
    
    
      <div class="crossnote markdown-preview  ">
      
<h1 id="lab5">Lab5 </h1>
<p>实验内容本身很简单，实现一个内存分配器，用来动态地管理内存分配和回收。即实现 <code>mm_malloc</code> <code>mm_free</code> <code>mm_realloc</code> 三个函数。使得能合理地对用户的内存请求进行分配和回收，并尽可能的提高内存利用率和吞吐率。</p>
<p>分配器有几点要求：</p>
<ol>
<li>除非用户询问，不能对分配的内存（包括地址和内容）做任何修改。</li>
<li>对用户的询问要做出立即响应。</li>
</ol>
<h2 id="具体算法">具体算法 </h2>
<p>教材中提供了 “隐式空闲链表” “显式空闲链表” “分离空闲链表” 三种方法。它们各有优劣。</p>
<p>我在实验中，分别实现了这三个链表，通过 <code>IMPLEMENTATION</code> 宏来选择具体实现。</p>
<p><img src="./Screenshots/define_implementation.png" alt="define_implementation"></p>
<p>分配器有大量的对指针的操作，以及内存对齐，指针计算等等，仿照教材的方法，将常用的一些运算使用宏定义封装</p>
<p><strong>由于一个块由头部（和前驱后继指针）和数据，而且和用户接触的都是数据域的指针，因此除非特别说明，所有的指针都指向块的数据域，对头部的访问，通过宏 <code>HDRP</code> 来完成。</strong></p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">HDRP</span><span class="token expression"><span class="token punctuation">(</span>bp<span class="token punctuation">)</span>        </span><span class="token comment">// 不同链表的块中数据域位置不同，需要在具体实现中分别定义</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DSIZE</span> <span class="token expression"><span class="token number">8</span>         </span><span class="token comment">// 双字，8字节，代码中用不到单字</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ALIGNMENT</span> <span class="token expression"><span class="token number">8</span>     </span><span class="token comment">// 内存对齐，8字节</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CLASS_NUM</span> <span class="token expression"><span class="token number">20</span>    </span><span class="token comment">// 块分类数量，只在分离空闲链表中用到</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">ALIGN</span><span class="token expression"><span class="token punctuation">(</span>size<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>ALIGNMENT<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token number">0x7</span><span class="token punctuation">)</span>   </span><span class="token comment">// 对齐，计算 size 向上取整到 8 的倍数</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">PACK</span><span class="token expression"><span class="token punctuation">(</span>size<span class="token punctuation">,</span> allocated<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>allocated<span class="token punctuation">)</span><span class="token punctuation">)</span>    </span><span class="token comment">// 在快头部中打包块大小和分配标记</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">READ</span><span class="token expression"><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">)</span>                 </span><span class="token comment">// 将 p 以 8 字节解引用</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">WRITE</span><span class="token expression"><span class="token punctuation">(</span>p<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword keyword-unsigned">unsigned</span> <span class="token keyword keyword-long">long</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span>   </span><span class="token comment">// 在 p 的位置写入 8 字节的 val</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">GET_SIZE</span><span class="token expression"><span class="token punctuation">(</span>word<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">READ</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token number">0</span>b111<span class="token punctuation">)</span>            </span><span class="token comment">// word 是块头部的指针，获取块大小</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">GET_ALLOC</span><span class="token expression"><span class="token punctuation">(</span>word<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token function">READ</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span> <span class="token operator">&amp;</span> <span class="token number">0</span>b1<span class="token punctuation">)</span>              </span><span class="token comment">// 获取分配标记</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">NEXT</span><span class="token expression"><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span>      </span><span class="token comment">// 计算紧邻的下一个块的地址，注意和 SUCC 做区分</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SUCC</span><span class="token expression"><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span>       </span><span class="token comment">// 计算后继块的地址，注意和 NEXT 做区分</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">PRED</span><span class="token expression"><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>       </span><span class="token comment">// 计算前驱块的地址</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">SET</span><span class="token expression"><span class="token punctuation">(</span>bp<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token function">WRITE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span> </span><span class="token comment">// 设置块的分配标记</span></span>
</code></pre><h2 id="implementation-1">Implementation 1 </h2>
<p>将堆空间视为足够大的数组，在其中划分出大小不一的块，作为链表的 “结点” ，每个块由两个部分构成，分别为 “头部” 和 “数据” 。头部中又包含两个信息 “大小” 和 “分配标记”，为了保证 <code>8</code> 字节对齐，块大小一定为 <code>8</code> 的倍数，那么它的低三位固定为 <code>0</code>，所以可以利用起来，作为分配标记。结点间的逻辑关系，由每个结点头部的大小域决定。如果能保证块与块之间紧密相连，那么通过读取块的大小，可以计算出后继块的地址。</p>
<p>关于空闲块的合并，没有使用教材中描述的 “立即合并”（在出现空闲块时，立即尝试合并周围的空闲块），而是使用 “推迟合并”（在需要空闲块时才尝试合并，否则保持不变）。正因如此，我没有使用脚部。脚部是方便寻找前驱，以便方便实现立即合并，而我的实现中不需要访问块的前驱，因此直接舍弃掉脚部。</p>
<p>可能用到的函数有</p>
<ol>
<li><code>mm_init</code> <code>mm_malloc</code> <code>mm_free</code> <code>mm_realloc</code> - 实验基本的函数，用于初始化，和接收请求</li>
<li><code>extend_heap</code> - 当堆中找不到合适的空闲块时，扩展堆本身，以创造新的空闲块。</li>
<li><code>coalesce_block</code> - 因为使用推迟合并，在遇到空闲块时，一定是相邻块中第一个空闲块，只需要向后合并。</li>
<li><code>cut_block</code> - 可能会遇到较大的空闲块，为避免浪费，将它切割成较小的块，切割出来的块标记为新的空闲块以便后续使用</li>
<li><code>first_fit</code> - 在寻找空闲块时有多种方法 “首次适配” “下一次适配” “最佳适配” 等，这里采用首次适配，利用块头部的大小信息，向后继跳转，将第一个找到的合适的空闲块作为分配的块，若找不到返回 <code>NULL</code>。</li>
</ol>
<p>基本流程如下：</p>
<ol>
<li>若收到 <code>malloc</code> 请求，执行 <code>first_fit</code> 函数，它会从堆开头找到第一个适配的块并返回，
<ol>
<li>若得到了空闲块的地址，执行 <code>cut_block</code> 将它分割成最小的足够大的块，标记为 “已分配” 作为返回值输出。</li>
<li>若得到了 <code>NULL</code>，说明堆中不存在合适的块，执行 <code>extend_heap</code> 扩展堆，创造新的空闲块，并将新块直接作为分配块它作为返回值。</li>
</ol>
</li>
<li>若收到 <code>free</code> 请求，将它的分配标记置 <code>0</code> 即可。</li>
<li>若收到 <code>realloc</code> 请求：
<ol>
<li>若请求的大小小于等于原块大小，执行 <code>cut_block</code> 将它分割，分割的新块作为空闲块，原块直接输出。</li>
<li>若大于原大小，首先尝试原地扩展，即用 <code>coalesce_block</code> 合并相邻的空闲块。在合并完成后若仍不能满足，则执行 <code>mm_malloc</code> 重新分配。然后调用 <code>memmove</code> 将原数据复制到新块中，对原块调用 <code>mm_free</code>，并返回新块的地址。</li>
</ol>
</li>
</ol>
<p>以下是具体实现的细节</p>
<p>通过全局变量 <code>heap</code> <code>heap_end</code> 来记录堆的起始地址和结束地址。</p>
<blockquote>
<p><em>这两个指针也是指向块的数据域地址，假设堆真正的始末地址分别为 <code>0x1000</code> 和 <code>0x2000</code>，那么 <code>heap == 0x1008, heap_end == 0x2008</code>。</em></p>
</blockquote>
<p><strong>关于首次适配</strong>：从 <code>heap</code> 开始遍历整个堆。每次访问到空闲块，如果满足要求直接返回，否则尝试合并块，根据合并结果，合并成功则不做操作继续检查这个块，合并失败则遍历只后继，最终返回适配块地址或 <code>NULL</code>。</p>
<blockquote>
<p><em>当访问到空闲块时，如果满足要求则返回，否则尝试合并。合并成功就重新访问自身，失败就说明这个块 （1. 不能满足要求，2. 不能合并），就遍历下一个块。</em><br>
<em>因为是从堆起始开始遍历，对每组连续的空闲块组，一定会访问到它的首个块。从首个块开始不需要向前合并。</em></p>
</blockquote>
<p><strong>关于切割块</strong>：因为空闲块至少需要一个头部，它的大小至少为 <code>8</code>，所以切割时，若剩余空间不足以容纳最小空闲块，则不切割，则不做操作，直接将多余部分一并作为块的内容。</p>
<blockquote>
<p><em>（其实由于对齐的存在，除非是块大小恰好满足的情况，一定可以切割，这使得检查的必要性在这个实现中体现不出来，后面的两个实现才会有用武之地）。</em></p>
</blockquote>
<p><strong>关于合并块</strong>：只有在后面存在块，并且是空闲块时，执行合并，并返回 <code>1</code> 表示合并成功，否则不做处理并返回 <code>0</code> 表示合并失败。</p>
<blockquote>
<p><em>由于上面提到的 <code>realloc</code> 中原地扩展的可能性，不对块本身做是否空闲的检查。这一点在第三个实现中有变化，在那里，已分配块和空闲块的合并分别由各自的函数实现。</em></p>
</blockquote>
<p><strong>关于扩展堆</strong>：为防止多余空间浪费，<strong>需要多少申请多少</strong>，将扩展出的空间标记为空闲块，不要忘记调整 <code>heap_end</code> 的值，并将 <strong>新堆空间的<em>真正</em>起始地址</strong> 返回。</p>
<blockquote>
<p><em>其实一开始尝试过 “缺多少申请多少”，即要先查询当前堆最后一个块的空闲（不空闲则取 0）的大小，将它和需求作差，扩展差值的堆空间，这样可以进一步提高空间利用率，但实现比较困难，遂放弃。</em><br>
<em>理论上返回数据块地址也是可行的，只需要在接收返回值的位置调整偏移即可，但一开始选择了真正地址，没有必要改变</em></p>
</blockquote>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span> <span class="token function">mm_init</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    heap <span class="token operator">=</span> <span class="token function">mem_sbrk</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> DSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//初始化时默认申请一个数据域大小为 0 的空块，总大小为 8 字节</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>heap <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword keyword-void">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword keyword-return">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    heap <span class="token operator">+=</span> DSIZE<span class="token punctuation">;</span>
    <span class="token function">WRITE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>heap<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">*</span> DSIZE<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    heap_end <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword keyword-char">char</span> <span class="token operator">*</span><span class="token punctuation">)</span>heap <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">*</span> DSIZE<span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-void">void</span> <span class="token function">cut_block</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span> <span class="token operator">*</span>bp<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">// 切割和合并块时注意，原块的分配标记要保持不变</span>
    <span class="token class-name">size_t</span> block_size <span class="token operator">=</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>block_size <span class="token operator">&gt;=</span> DSIZE <span class="token operator">+</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">WRITE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">WRITE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">+</span> size<span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>block_size <span class="token operator">-</span> size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-int">int</span> <span class="token function">coalesce_block</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span> <span class="token operator">*</span>bp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-void">void</span> <span class="token operator">*</span>next_bp <span class="token operator">=</span> <span class="token function">NEXT</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>next_bp <span class="token operator">&gt;=</span> heap_end <span class="token operator">||</span> <span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>next_bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">WRITE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span><span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>next_bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-void">void</span> <span class="token operator">*</span><span class="token function">extend_heap</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-void">void</span> <span class="token operator">*</span>new_area <span class="token operator">=</span> <span class="token function">mem_sbrk</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>new_area <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword keyword-void">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword keyword-return">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token function">WRITE</span><span class="token punctuation">(</span>new_area<span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    heap_end <span class="token operator">+=</span> size<span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> new_area<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-void">void</span> <span class="token operator">*</span><span class="token function">first_fit</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-void">void</span> <span class="token operator">*</span>currentbp <span class="token operator">=</span> heap<span class="token punctuation">;</span>
    <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span>currentbp <span class="token operator">&lt;</span> heap_end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">GET_ALLOC</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>currentbp<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 
            currentbp <span class="token operator">=</span> <span class="token function">NEXT</span><span class="token punctuation">(</span>currentbp<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword keyword-continue">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>currentbp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> size<span class="token punctuation">)</span>
            <span class="token keyword keyword-return">return</span> currentbp<span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">coalesce_block</span><span class="token punctuation">(</span>currentbp<span class="token punctuation">)</span><span class="token punctuation">)</span> 
            currentbp <span class="token operator">=</span> <span class="token function">NEXT</span><span class="token punctuation">(</span>currentbp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-void">void</span> <span class="token operator">*</span><span class="token function">mm_malloc</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    size <span class="token operator">=</span> <span class="token function">ALIGN</span><span class="token punctuation">(</span>size <span class="token operator">+</span> DSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>     
    <span class="token keyword keyword-void">void</span> <span class="token operator">*</span>currentbp <span class="token operator">=</span> <span class="token function">first_fit</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>currentbp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        currentbp <span class="token operator">=</span> <span class="token function">extend_heap</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span> <span class="token operator">+</span> DSIZE<span class="token punctuation">;</span>  <span class="token comment">// extend_heap 的返回值是真正地址，注意偏移到数据域</span>
    <span class="token function">cut_block</span><span class="token punctuation">(</span>currentbp<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token function">WRITE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>currentbp<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> currentbp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-void">void</span> <span class="token function">mm_free</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>ptr <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword keyword-return">return</span><span class="token punctuation">;</span>
    <span class="token function">SET</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 只需设标记为空闲，至于合并，等待后续访问</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-void">void</span> <span class="token operator">*</span><span class="token function">mm_realloc</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-void">void</span> <span class="token operator">*</span>newptr <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>ptr <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword keyword-return">return</span> <span class="token function">mm_malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token keyword keyword-return">return</span> <span class="token function">mm_free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    
    size <span class="token operator">=</span> <span class="token function">ALIGN</span><span class="token punctuation">(</span>size <span class="token operator">+</span> DSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 实际需要要多一个 8 字节头部</span>
    <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span><span class="token function">coalesce_block</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">//尽可能多合并</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> size<span class="token punctuation">)</span>
        <span class="token keyword keyword-return">return</span> <span class="token function">cut_block</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">,</span> ptr<span class="token punctuation">;</span>
    newptr <span class="token operator">=</span> <span class="token function">mm_malloc</span><span class="token punctuation">(</span>size <span class="token operator">-</span> DSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 如果能到达这里说明上面的尝试都失败了，只能重新分配</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>newptr <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
        <span class="token keyword keyword-return">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token function">memmove</span><span class="token punctuation">(</span>newptr<span class="token punctuation">,</span> ptr<span class="token punctuation">,</span> <span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span> DSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">WRITE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>newptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span><span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>newptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-return">return</span> <span class="token function">mm_free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">,</span> newptr<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p><img src="./Screenshots/implementation_1_result.png" alt="implementation_1_res" width="50%"></p>
<h2 id="implementation-2">Implementation 2 </h2>
<p>可以看到，上面的结果中，空间利用率比较不错，吞吐率仍然有提升空间。</p>
<p>事实上，绝大部分时间都用在寻找适配块上，而寻找适配块的 <code>first_fit</code> 中，又有大部分时间在访问已分配块，尽管直接跳过，但还是极大的浪费。一个优化方法是，将空闲块直接链接起来，通过在空闲块中加入两个指针，指向它的前一个和后一个空闲块，分别叫做 “前驱” 和 “后继” 指针，形成显式空闲链表。</p>
<p>随着空闲块中，前驱指针域和后继指针域的加入，导致这些问题的出现：</p>
<ul>
<li>最小空闲块<br>
原本最小空闲块是仅有一个头部的 8 字节大小，现在成为了 “头部” “前驱指针” “后继指针” 三个部分，最小大小变成了 24 字节。这确实会降低空间利用率，但从结果上可以看到，对吞吐率的提升远大于利用率的降低。</li>
<li>已分配块不变<br>
已分配块不需要前驱和后继指针，因为这两个指针是为了寻找空闲块时加快速度。所以在将空闲块分配出去时，指针域可以舍弃，并入已分配块的数据域之中，仍只有头部，要注意输入输出时的偏移</li>
<li>数据域偏移<br>
上面这点又会导致，两种块的数据域的位置不同，而像开头所说那样，提及块地址时默认指数据域地址，所以要对它们作出区分，在代码和后文中，将会以 <code>bp</code> 代指空闲块的数据域地址（<code>头部地址 + 3 * DSIZE</code>），以 <code>ptr</code> 代指已分配块的数据域地址（<code>头部地址 + 1 * DSIZE</code>）</li>
<li>宏定义<br>
另外增加获取前驱和后继块的宏，已经写在开头的宏定义中同时，从块地址获取头部地址的 <code>HDRP(bp)</code> 宏也要修改：从 <code>#define HDRP(bp) (char *)((unsigned long *)(bp) - 1)</code> 修改为 <code>#define HDRP(bp) (char *)((unsigned long *)(bp) - 3)</code></li>
</ul>
<p>还有很多其它的改变</p>
<ul>
<li>链表的末尾标志<br>
由于这个链表是人工维护，不能直接使用的 <code>heap_end</code>，需要一个额外结点表示链表末尾，如果将链表设置为循环链表，那么它的后继就是链表开头，不需要额外的开头结点。在遍历空闲块时，只需从末尾块的后继开始，回到末尾块结束。在代码中，将 <code>heap</code> 变量设定位链表尾结点，而非堆起始。</li>
<li>链表操作<br>
由于要直接维护链表，需要结点的删插操作，编写两个函数将其包装</li>
<li>插入到末尾<br>
像教材中提到的那样，新的空闲块应当放在显式链表的什么位置，由于我们记录了链表的尾结点，插入到尾结点时很直接的做法，不必实现特定位置插入的函数，用不上。</li>
<li>合并不完全<br>
合并块时，现在不能保证连续的空闲块一定从首个空闲块开始合并，如果迟迟找不到可适配的块，可以保证总能访问到首个，但如果提前找到了，确实有可能在块前面存在没被合并的空闲块，这是推迟合并的弊端。</li>
</ul>
<p>以下是代码，只将重要的修改贴出来，其他简单修改就省略了。完整代码可以直接看 <code>mm.c</code></p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-int">int</span> <span class="token function">mm_init</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    heap <span class="token operator">=</span> <span class="token function">mem_sbrk</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">*</span> DSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 最小空闲块为 3 个双字，作为尾结点</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>heap <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword keyword-void">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword keyword-return">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    heap <span class="token operator">=</span> heap <span class="token operator">+</span> <span class="token number">3</span> <span class="token operator">*</span> DSIZE<span class="token punctuation">;</span>
    <span class="token function">WRITE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>heap<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">*</span> DSIZE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 单独标记为已分配，以防可能的意外（事实上没有意外</span>
    <span class="token function">PRED</span><span class="token punctuation">(</span>heap<span class="token punctuation">)</span> <span class="token operator">=</span> heap<span class="token punctuation">;</span>                      <span class="token comment">// 在链表为空时，前驱和后继都指向自己</span>
    <span class="token function">SUCC</span><span class="token punctuation">(</span>heap<span class="token punctuation">)</span> <span class="token operator">=</span> heap<span class="token punctuation">;</span>
    heap_end <span class="token operator">=</span> heap <span class="token operator">+</span> <span class="token number">3</span> <span class="token operator">*</span> DSIZE<span class="token punctuation">;</span>            <span class="token comment">// heap_end 仍然表示堆的末尾</span>
    <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-void">void</span> <span class="token operator">*</span><span class="token function">first_fit</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-void">void</span> <span class="token operator">*</span>currentbp <span class="token operator">=</span> <span class="token function">SUCC</span><span class="token punctuation">(</span>heap<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// 优化的核心，仅访问空闲块</span>
    <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span>currentbp <span class="token operator">!=</span> heap<span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment">// 跳过已分配块的代码也可以删掉了</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">coalesce_block</span><span class="token punctuation">(</span>currentbp<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword keyword-continue">continue</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>currentbp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> size<span class="token punctuation">)</span>
            <span class="token keyword keyword-return">return</span> currentbp<span class="token punctuation">;</span>
        currentbp <span class="token operator">=</span> <span class="token function">SUCC</span><span class="token punctuation">(</span>currentbp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword keyword-return">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-void">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span> <span class="token operator">*</span>bp<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment">// 默认插入到尾结点前面</span>
    <span class="token function">PRED</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">PRED</span><span class="token punctuation">(</span>heap<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">SUCC</span><span class="token punctuation">(</span><span class="token function">PRED</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> bp<span class="token punctuation">;</span>
    <span class="token function">SUCC</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span> <span class="token operator">=</span> heap<span class="token punctuation">;</span>
    <span class="token function">PRED</span><span class="token punctuation">(</span><span class="token function">SUCC</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> bp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-void">void</span> <span class="token function">erase</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span> <span class="token operator">*</span>bp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">PRED</span><span class="token punctuation">(</span><span class="token function">SUCC</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">PRED</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">SUCC</span><span class="token punctuation">(</span><span class="token function">PRED</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">SUCC</span><span class="token punctuation">(</span>bp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-static">static</span> <span class="token keyword keyword-void">void</span> <span class="token function">cut_block</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span> <span class="token operator">*</span>bp<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>   
<span class="token comment">// 其中切割条件判断改为 block_size &gt;= 3 * DSIZE + size</span>
<span class="token comment">// 因为最小空闲块的大小变成了 3 个双字</span>
<span class="token comment">// 以及，切割的新块要 insert 到空闲链表中</span>

<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-int">int</span> <span class="token function">coalesce_block</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span> <span class="token operator">*</span>bp<span class="token punctuation">)</span>
<span class="token comment">// 合并掉的块从链表中 erase 掉</span>

<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-void">void</span> <span class="token operator">*</span><span class="token function">extend_heap</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> size<span class="token punctuation">)</span>
<span class="token comment">// 添加了  if (size &lt;= 3 * DSIZE) size = 3 * DSIZE; </span>
<span class="token comment">// 保证最小空闲块的大小为 3 个双字</span>
<span class="token comment">// 以及空闲块的 insert</span>

<span class="token keyword keyword-void">void</span> <span class="token operator">*</span><span class="token function">mm_malloc</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    size <span class="token operator">=</span> <span class="token function">ALIGN</span><span class="token punctuation">(</span>size <span class="token operator">+</span> DSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-void">void</span> <span class="token operator">*</span>currentbp <span class="token operator">=</span> <span class="token function">first_fit</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span>currentbp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/* 这里也可以修改为 currentbp = extend_heap(size) + DSIZE; */</span>
        <span class="token comment">/* 能实现，因为扩展后的新块肯定可以满足 */</span>
        <span class="token comment">/* 但这会使得这个块前面可能存在的小块空闲不被使用，造成浪费*/</span>
        <span class="token comment">/* 而重新搜索消耗的时间，不会影响分数，所以不采用 */</span>
        <span class="token comment">/* 相较于上一个实现，这里的空间利用率价值更大 */</span>
        <span class="token function">extend_heap</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
        currentbp <span class="token operator">=</span> <span class="token function">first_fit</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">cut_block</span><span class="token punctuation">(</span>currentbp<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token function">erase</span><span class="token punctuation">(</span>currentbp<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">SET</span><span class="token punctuation">(</span>currentbp<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword keyword-return">return</span> currentbp <span class="token operator">-</span> <span class="token number">2</span> <span class="token operator">*</span> DSIZE<span class="token punctuation">;</span>       <span class="token comment">// 数据域位置不同</span>
<span class="token punctuation">}</span>

<span class="token keyword keyword-void">void</span> <span class="token function">mm_free</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span>
<span class="token comment">// free 后 insert</span>

<span class="token keyword keyword-void">void</span> <span class="token operator">*</span><span class="token function">mm_realloc</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">,</span> <span class="token class-name">size_t</span> size<span class="token punctuation">)</span>
<span class="token comment">// 最重要的是空闲块和已分配块的数据域位置问题，需要将 ptr 和 bp 分开处理，其余不变。</span>
</code></pre><p><img src="./Screenshots/implementation_2_result.png" alt="implementation_2_res" width="50%"></p>
<h2 id="implementation-3">Implementation 3 </h2>
<p>还有另一种实现方法，根据空闲块大小不同，分成多个不同链表</p>
<p>例如，将大小为 <code>0 ~ 32</code> 的块放入一个列表，<code>33 ~ 64</code> 的块放入另一个列表，<code>65 ~ 128</code> 的块放入第三个列表，以此类推。</p>
<p>这样，查找和分配块时，只需要遍历相应的链表即可，而不需要在整个堆中寻找，可以进一步优化。</p>
<p>我实际采用的也正是按照 <code>2</code> 的幂次划分，将它们总共分为了 <code>15</code> 个链表。</p>
<p>一些其它的修改有：</p>
<ul>
<li>多个链表<br>
现在有多个链表，也就有多个尾结点，将它们分布在堆的开头，和上一个实现中类似</li>
<li>链表选择<br>
因为有多个链表存在，不能再使用唯一的 <code>heap</code> 变量来定位，而是需要根据块的大小选择相应的链表，添加函数 <code>find_list</code> 用于找到对应链表，返回值是链表的尾结点，和上一个实现中的 <code>heap</code> 是等价的。</li>
<li>块大小的调整<br>
在合并和切割块时，块大小需要修改，如果恰好修改前后对应的链表不同，需要修改它具体所在的链表，实现中为了简便，实际上会先把原块全部 <code>erase</code>，操作后再 <code>insert</code>。</li>
<li><code>realloc</code> 的调整<br>
正是因为上一条，倘若是在 <code>realloc</code> 中调用的 <code>coalesce_block</code> 或 <code>cut_block</code>，那么块是已分配的，不再空闲链表中，这时从链表中 <code>erase</code> 会发生内存泄漏的段错误，所以需要编写用于已分配块的合并和切割函数，分别叫做 <code>expand_block</code> 和 <code>shrink_block</code>；后两者和之前的函数一样，前两者需要添加对参数 <code>bp</code> 的 <code>erase</code> 和 <code>insert</code> 操作。</li>
</ul>
<p>比较重要的修改有</p>
<pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token keyword keyword-static">static</span> <span class="token keyword keyword-void">void</span> <span class="token operator">*</span><span class="token function">find_list</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">// 在堆起始处存放有每个链表的尾结点，找到大小对应的链表的尾结点</span>
    <span class="token keyword keyword-int">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> CLASS_NUM <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword keyword-return">return</span> <span class="token punctuation">(</span>heap <span class="token operator">+</span> i <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">*</span> DSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token keyword keyword-return">return</span> <span class="token punctuation">(</span>heap <span class="token operator">+</span> <span class="token punctuation">(</span>CLASS_NUM <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">*</span> DSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">/* 对多个链表的初始化，形式和大不相同。每一个链表的尾结点都指向自己的初始化。
 */</span>
<span class="token keyword keyword-int">int</span> <span class="token function">mm_init</span><span class="token punctuation">(</span><span class="token keyword keyword-void">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-int">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    heap <span class="token operator">=</span> <span class="token function">mem_sbrk</span><span class="token punctuation">(</span>CLASS_NUM <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">*</span> DSIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span>heap <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token keyword keyword-void">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
        <span class="token keyword keyword-return">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    heap <span class="token operator">+=</span> <span class="token number">3</span> <span class="token operator">*</span> DSIZE<span class="token punctuation">;</span>
    heap_end <span class="token operator">=</span> heap <span class="token operator">+</span> CLASS_NUM <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">*</span> DSIZE<span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> CLASS_NUM<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">WRITE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>heap <span class="token operator">+</span> i <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">*</span> DSIZE<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">PACK</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">*</span> DSIZE<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">SUCC</span><span class="token punctuation">(</span>heap <span class="token operator">+</span> i <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">*</span> DSIZE<span class="token punctuation">)</span> <span class="token operator">=</span> heap <span class="token operator">+</span> i <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">*</span> DSIZE<span class="token punctuation">;</span>
        <span class="token function">PRED</span><span class="token punctuation">(</span>heap <span class="token operator">+</span> i <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">*</span> DSIZE<span class="token punctuation">)</span> <span class="token operator">=</span> heap <span class="token operator">+</span> i <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">*</span> DSIZE<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword keyword-return">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><pre data-role="codeBlock" data-info="c" class="language-c c"><code><span class="token comment">/*
 * link_end 指链表的尾结点
 * 因为只需要从大小更大的链表开始寻找，所以循环的初始值是 find_list(size)
 * 在链表内的操作和上一个实现完全一致，当一个链表找不到合适的块时，才会进入下一个链表
 */</span>
<span class="token keyword keyword-static">static</span> <span class="token keyword keyword-void">void</span> <span class="token operator">*</span><span class="token function">first_fit</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword keyword-void">void</span> <span class="token operator">*</span>link_end <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword keyword-for">for</span><span class="token punctuation">(</span>link_end <span class="token operator">=</span> <span class="token function">find_list</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span> link_end <span class="token operator">&lt;</span> heap <span class="token operator">+</span> CLASS_NUM <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">*</span> DSIZE<span class="token punctuation">;</span> link_end <span class="token operator">=</span> <span class="token function">NEXT</span><span class="token punctuation">(</span>link_end<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword keyword-void">void</span> <span class="token operator">*</span>currentbp <span class="token operator">=</span> <span class="token function">SUCC</span><span class="token punctuation">(</span>link_end<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword keyword-while">while</span><span class="token punctuation">(</span>currentbp <span class="token operator">!=</span> link_end<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword keyword-if">if</span> <span class="token punctuation">(</span><span class="token function">coalesce_block</span><span class="token punctuation">(</span>currentbp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                currentbp <span class="token operator">=</span> <span class="token function">SUCC</span><span class="token punctuation">(</span>link_end<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword keyword-continue">continue</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword keyword-if">if</span><span class="token punctuation">(</span><span class="token function">GET_SIZE</span><span class="token punctuation">(</span><span class="token function">HDRP</span><span class="token punctuation">(</span>currentbp<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> size<span class="token punctuation">)</span>
                <span class="token keyword keyword-return">return</span> currentbp<span class="token punctuation">;</span>
            currentbp <span class="token operator">=</span> <span class="token function">SUCC</span><span class="token punctuation">(</span>currentbp<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword keyword-return">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><p><code>static void insert(void *bp)</code><br>
在开头添加 <code>void *res = find_list(GET_SIZE(HDRP(bp)));</code> 语句，用于寻找对应的链表，其中 <code>res</code> 仅替换原本的 <code>heap</code> 变量，其余不变。</p>
<p>以及上文中提到的 <code>expand_block</code> 和 <code>shrink_block</code> 函数，它们的实现和之前的函数一样；用于替换 <code>realloc</code> 中的 <code>coalesce_block</code> 和 <code>cut_block</code> 函数。同时原本的 <code>coalesce_block</code> 和 <code>cut_block</code> 函数则添加 <code>erase(bp)</code> 和 <code>insert(bp)</code> 操作，以适应多个链表。</p>
<p><img src="./Screenshots/implementation_3_result.png" alt="implementation_3_res" width="50%"></p>
<p>非常明显的是，吞吐率的提升幅度极大，甚至是在跑测评程序时都能感受到明显的更快。</p>
<p>但令我意外且失望的是，它的空间利用率意外地很低，比前两个实现都要低，链表类数越高利用率越低。</p>
<p>理论上来讲因为它总是尽可能先使用小较小的块，空间利用率应当接近最佳适配，但实际上并不理想，可能是我程序实现的问题，也可能是其它问题，姑且先不深究了。</p>
<h2 id="总结">总结 </h2>
<p>综上。这次实验思路不难，但代码实现非常困难，由 <code>WakaTime</code> 统计的编程时间大于 <code>24</code> 小时。倘若没有使用 <code>VSCode</code> 而是命令行 <code>gdb</code> 调试，必然是更大的挑战。</p>
<p>实现了三种不同的分配方法，结果分别为：</p>
<p><img src="./Screenshots/implementation_1_result.png" alt="result_1" width="50%"></p>
<p><img src="./Screenshots/implementation_2_result.png" alt="result_2" width="50%"></p>
<p><img src="./Screenshots/implementation_3_result.png" alt="result_3" width="50%"></p>
<p>除了意料之外的分离空闲链表的低利用率之外，其它结果都满意。<br>
完整代码可以直接看 <code>mm.c</code>，通过 <code>84</code> 行的 <code>#define IMPLEMENTATION ?</code>来选择哪种实现</p>

      </div>
      
      
    
    
    
    
    
    
  
    </body></html>